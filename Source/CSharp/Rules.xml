<rules>
    <headers>
        <include>Container/RefCounted.h</include>
        <include>Math/StringHash.h</include>
        <include>Core/Object.h</include>
        <include>Core/Context.h</include>
        <include>Core/Variant.h</include>
        <include>Engine/*.h</include>
    </headers>
    <compiler>
        <define>URHO3D_API</define>
    </compiler>
    <types>
        <include>Urho3D::*</include>
        <exclude>Urho3D::ObjectFactory</exclude>
        <exclude>Urho3D::EventHandler*</exclude>
        <exclude>Urho3D::EventNameRegistrar</exclude>
        <exclude>Urho3D::ObjectFactoryImpl</exclude>
        <exclude>Urho3D::CustomVariantValue*</exclude>
        <exclude>Urho3D::String</exclude>
        <exclude>Urho3D::WString</exclude>
        <exclude>Urho3D::StringHash</exclude>
    </types>
    <typemaps>
        <typemap type="Urho3D::StringHash" ctype="unsigned" cstype="Urho3D.StringHash">
            <cpp_to_c>{{value}}.Value()</cpp_to_c>
            <c_to_cpp>Urho3D::StringHash({{value}})</c_to_cpp>
            <pinvoke_to_cs>new StringHash({{value}})</pinvoke_to_cs>
            <cs_to_pinvoke>{{value}}.Hash</cs_to_pinvoke>
        </typemap>
        <!-- TODO: Avoid string copying when possible.
        String typemaps always return a copy of string which is freed by mono. Sometimes this is not necessary and c api
        could return pointer pointing to string content held by the engine. However mono is required to not free such
        string after conversion, which implies handling it manually. Also investigate how .net framework behaves in this
        situation.
        -->
        <typemap type="Urho3D::String" ctype="char const*" cstype="string">
            <cpp_to_c>strdup({{value}}.CString())</cpp_to_c>
            <c_to_cpp>Urho3D::String({{value}})</c_to_cpp>
        </typemap>
        <typemap type="char const*">
            <cpp_to_c>strdup({{value}})</cpp_to_c>
        </typemap>
    </typemaps>
</rules>
